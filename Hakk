rPerfect! Let's use Material UI (MUI) for styling and components. Here's a fully enhanced React frontend using MUI, with the following features:


---

✅ Features Included:

Material UI design

Toggle log types (API Logs / Cron Logs)

Shows environment label

Refresh logs

Download logs

Last updated time

Search/filter inside logs

Keyword highlighting (error, fail, exception, warning)

Error handling



---

React Frontend (Enhanced with Material UI)

Install Required Packages:

npm install @mui/material @emotion/react @emotion/styled axios


---

LogViewer.jsx

import React, { useState, useEffect } from 'react';
import {
  AppBar, Toolbar, Typography, Button, Container,
  ToggleButtonGroup, ToggleButton, Box, TextField, Paper, Snackbar, Alert
} from '@mui/material';
import axios from 'axios';

const LOG_TYPES = {
  api: 'API Logs',
  cron: 'Cron Logs',
};

const KEYWORDS = ['error', 'fail', 'exception', 'warning'];

const highlightText = (text) => {
  let escaped = text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
  const regex = new RegExp(`\\b(${KEYWORDS.join('|')})\\b`, 'gi');
  return escaped.replace(regex, match => `<mark style="background-color: #ff9800; color: black;">${match}</mark>`);
};

export default function LogViewer() {
  const [logType, setLogType] = useState('api');
  const [logContent, setLogContent] = useState('');
  const [filteredContent, setFilteredContent] = useState('');
  const [searchTerm, setSearchTerm] = useState('');
  const [lastUpdated, setLastUpdated] = useState('');
  const [env, setEnv] = useState('dev'); // Can come from backend
  const [errorMsg, setErrorMsg] = useState('');

  const fetchLogs = async () => {
    try {
      const response = await axios.get(`/logs/${logType}`);
      const now = new Date().toLocaleString();
      setLogContent(response.data);
      setLastUpdated(now);
      setErrorMsg('');
    } catch (err) {
      setErrorMsg('Error fetching logs');
      setLogContent('');
    }
  };

  useEffect(() => {
    fetchLogs();
  }, [logType]);

  useEffect(() => {
    if (searchTerm) {
      const filtered = logContent
        .split('\n')
        .filter(line => line.toLowerCase().includes(searchTerm.toLowerCase()))
        .join('\n');
      setFilteredContent(filtered);
    } else {
      setFilteredContent(logContent);
    }
  }, [searchTerm, logContent]);

  const handleDownload = () => {
    const blob = new Blob([filteredContent], { type: 'text/plain' });
    const link = document.createElement('a');
    link.href = window.URL.createObjectURL(blob);
    link.download = `${logType}_logs.txt`;
    link.click();
  };

  return (
    <Box>
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6" sx={{ flexGrow: 1 }}>
            Log Viewer - {env.toUpperCase()}
          </Typography>
          <Button color="inherit" onClick={fetchLogs}>Refresh</Button>
        </Toolbar>
      </AppBar>

      <Container sx={{ mt: 4 }}>
        <ToggleButtonGroup
          value={logType}
          exclusive
          onChange={(e, val) => val && setLogType(val)}
          aria-label="log type"
          sx={{ mb: 2 }}
        >
          {Object.entries(LOG_TYPES).map(([key, label]) => (
            <ToggleButton key={key} value={key}>{label}</ToggleButton>
          ))}
        </ToggleButtonGroup>

        <Box display="flex" alignItems="center" gap={2} mb={2}>
          <TextField
            label="Search logs"
            variant="outlined"
            value={searchTerm}
            onChange={e => setSearchTerm(e.target.value)}
            fullWidth
          />
          <Button variant="contained" color="primary" onClick={handleDownload}>
            Download
          </Button>
        </Box>

        <Typography variant="caption" gutterBottom>
          Last updated: {lastUpdated}
        </Typography>

        <Paper
          elevation={3}
          sx={{
            bgcolor: '#1e1e1e',
            color: '#e0e0e0',
            p: 2,
            height: 500,
            overflow: 'auto',
            whiteSpace: 'pre-wrap',
            fontFamily: 'monospace',
          }}
          dangerouslySetInnerHTML={{ __html: highlightText(filteredContent) }}
        />

        <Snackbar open={!!errorMsg} autoHideDuration={6000} onClose={() => setErrorMsg('')}>
          <Alert severity="error" onClose={() => setErrorMsg('')}>{errorMsg}</Alert>
        </Snackbar>
      </Container>
    </Box>
  );
}


---

Flask Backend (for API Endpoint)

Here’s a matching Flask backend for the frontend above:

from flask import Flask, send_file, jsonify
import os
from flask_cors import CORS

app = Flask(__name__)
CORS(app)

branch_name = os.getenv('BRANCH_NAME', 'dev')
is_dev = branch_name in ['dev', 'local']

LOG_FILES = {
    'api': os.path.join('log', 'dev_api_errors.log' if is_dev else 'api_errors.log'),
    'cron': os.path.join('log', 'dev_cron_jobs.log' if is_dev else 'cron_jobs.log'),
}

@app.route('/logs/<log_type>', methods=['GET'])
def get_logs(log_type):
    path = LOG_FILES.get(log_type)
    if not path or not os.path.exists(path):
        return jsonify({'error': 'Log file not found'}), 404
    with open(path, 'r') as file:
        content = file.read()
    return content, 200, {'Content-Type': 'text/plain'}


---

Next Steps

Place the LogViewer.jsx component in your React app.

Set up a proxy to your Flask API (in vite.config.js or package.json).

Ensure CORS is enabled on the Flask side.


Would you like a downloadable full project boilerplate for this? I can structure the folders and prepare a ZIP.

