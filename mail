Frontend React Code Update

Below is the updated React component to include the checkbox for LSB_OPTION and the textbox for the SLOT_POOL. If the checkbox is checked, the SLOT_POOL textbox becomes visible, and its value is submitted along with the other data.


---

import { DevTool } from '@hookform/devtools';
import dayjs from 'dayjs';
import React, { Fragment, useContext, useState } from 'react';
import { Controller, useForm } from 'react-hook-form';
import { useQuery } from '@tanstack/react-query';
import { useDebounce } from 'use-debounce';
import apiInstance from '../../../api';
import { ClusterContext } from '../../../NotificationContext';

const QueueFormPriority = () => {
  const { userID } = useContext(ClusterContext);
  const {
    control,
    handleSubmit,
    formState: { errors },
    reset,
    watch,
    setValue,
  } = useForm({
    mode: 'onChange',
  });

  const today = dayjs();

  const onSubmit = async (data) => {
    if (data.PG_DATE) {
      data.PG_DATE = data.PG_DATE.toISOString().split('T')[0];
    }
    data.STATUS = 'requested';
    data.USER_AID = userID;
    data.SUBMISSION_DATE = today.toISOString().split('T')[0];

    data.GROUP_AID = data.GROUP_AID ? data.GROUP_AID.map((item) => item.uid).join(',') : '';
    data.LSB_OPTION = data.LSB_OPTION || false; // Checkbox value
    data.SLOT_POOL = data.LSB_OPTION ? data.SLOT_POOL : '35'; // Default to 35 if checkbox is unchecked

    console.log(data, 'Submitted Data');

    try {
      const response = await apiInstance.post('/queueaccess', data);
      if (response.status === 200) {
        setOpenSnackbar(true);
        setSnackMessage(response.data.message);
      }
    } catch (error) {
      console.error('Error while submitting:', error);
    }
  };

  const [inputValue, setInputValue] = useState('');
  const [debouncedInputValue] = useDebounce(inputValue, 1000);
  const [openSnackbar, setOpenSnackbar] = useState(false);
  const [snackMessage, setSnackMessage] = useState('');

  const fetchLDAP = async (inputValue) => {
    const res = await apiInstance.get(`/ldap?userInput=${inputValue}`);
    return res.data || {};
  };

  const { data: ldapData = [], isLoading } = useQuery(['ldap', debouncedInputValue], () =>
    fetchLDAP(debouncedInputValue)
  );

  const handleCloseSnackbar = () => setOpenSnackbar(false);

  return (
    <>
      <Paper elevation={24} square={false}>
        <form onSubmit={handleSubmit(onSubmit)} noValidate>
          <Grid
            container
            borderRadius={2}
            ml={0}
            rowSpacing={1}
            pb={1}
            pr={1}
            columnSpacing={1}
            justifyContent={'center'}
            alignItems={'center'}
          >
            <Grid item md={6}>
              <FormControl fullWidth variant="outlined">
                <Controller
                  name="GROUP_AID"
                  control={control}
                  render={({ field }) => (
                    <Autocomplete
                      {...field}
                      multiple
                      id="GROUP_AID"
                      disableCloseOnSelect
                      loading={isLoading}
                      loadingText={'Searching ...'}
                      options={ldapData || []}
                      getOptionLabel={(option) => `${option.cn} (${option.uid})`}
                      onChange={(e, value) => setValue('GROUP_AID', value)}
                      value={field.value || []}
                      isOptionEqualToValue={(option, value) => option.uid === value.uid}
                      filterOptions={(x) => x}
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          onChange={(e) => setInputValue(e.target.value)}
                          label="Enter Other AIDs"
                          placeholder="Group AIDs"
                          InputProps={{
                            ...params.InputProps,
                            endAdornment: (
                              <>
                                {isLoading ? <CircularProgress color="inherit" size={20} /> : null}
                                {params.InputProps.endAdornment}
                              </>
                            ),
                          }}
                        />
                      )}
                    />
                  )}
                />
              </FormControl>
            </Grid>

            {/* LSB_OPTION Checkbox */}
            <Grid item md={6}>
              <Controller
                name="LSB_OPTION"
                control={control}
                defaultValue={false}
                render={({ field }) => (
                  <FormControlLabel
                    control={<Checkbox {...field} checked={field.value} />}
                    label="Edit LSB File?"
                  />
                )}
              />
            </Grid>

            {/* SLOT_POOL Textbox (Visible Only If LSB_OPTION is Checked) */}
            {watch('LSB_OPTION') && (
              <Grid item md={6}>
                <Controller
                  name="SLOT_POOL"
                  control={control}
                  defaultValue="35"
                  render={({ field }) => (
                    <TextField
                      {...field}
                      label="Slot Pool"
                      placeholder="Enter Slot Pool"
                      variant="outlined"
                      fullWidth
                    />
                  )}
                />
              </Grid>
            )}
          </Grid>

          <Stack spacing={2} direction={'row'} justifyContent={'center'} p={2}>
            <Button type="submit" variant="contained" color="primary">
              Submit
            </Button>
            <Button type="button" variant="contained" color="primary" onClick={() => reset()}>
              Reset
            </Button>
          </Stack>
        </form>
      </Paper>

      <Snackbar
        open={openSnackbar}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
        anchorOrigin={{ horizontal: 'center', vertical: 'bottom' }}
      >
        <Alert onClose={handleCloseSnackbar} severity="success" variant="filled" sx={{ width: '100%' }}>
          {snackMessage}
        </Alert>
      </Snackbar>

      <DevTool control={control} />
    </>
  );
};

export default QueueFormPriority;


---

Backend Flask Code

The backend receives the data sent from the form and triggers a Jenkins pipeline with the provided parameters.

from flask import Flask, request, jsonify
import requests

app = Flask(__name__)

# Endpoint to handle the form submission
@app.route('/queueaccess', methods=['POST'])
def queue_access():
    try:
        data = request.json

        # Extract form data
        user_ids = data.get('GROUP_AID', '')
        lsb_option = data.get('LSB_OPTION', False)
        slot_pool = data.get('SLOT_POOL', '35')

        # Jenkins API call
        jenkins_url = 'http://jenkins-server-url/job/queue-pipeline/buildWithParameters'
        jenkins_params = {
            'USER_IDS': user_ids,
            'LSB_OPTION': lsb_option,
            'SLOT_POOL': slot_pool,
        }

        # Jenkins authentication
        auth = ('jenkins_user', 'jenkins_token')

        response = requests.post(jenkins_url, params=jenkins_params, auth=auth)
        if response.status_code == 201:
            return jsonify({'message': 'Pipeline triggered successfully.'}), 200
        else:
            return jsonify({'error': 'Failed to trigger pipeline.'}), 500

    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)


---

Key Points

1. Frontend:

The LSB_OPTION checkbox dynamically controls the visibility of the SLOT_POOL textbox.

The form submits LSB_OPTION and SLOT_POOL values with the user IDs.



2. Backend:

The Flask app processes the form data and sends a Jenkins build request with parameters.

The LSB_OPTION determines whether to include the SLOT_POOL in the pipeline.




Let me know if you need further enhancements!

