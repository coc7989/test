If you want to use requests.get and requests.post to trigger Jenkins builds and fetch the job's result status instead of using the Jenkins Python library, you can interact directly with the Jenkins REST API.


---

Steps to Trigger Build and Fetch Result

1. Trigger a Jenkins Build: Use a POST request to the Jenkins build URL with parameters.


2. Poll for Build Status: Use a GET request to check the status of the triggered build.




---

Updated Code for Triggering Jenkins Build

1. Trigger Build: Jenkins job URL typically follows this format:

Trigger build: POST http://<jenkins-url>/job/<job-name>/buildWithParameters

Add parameters and credentials for authentication.



2. Fetch Build Status:

Use Jenkins's API to poll the status of the last build: GET http://<jenkins-url>/job/<job-name>/lastBuild/api/json





---

Code Implementation

import requests
from time import sleep

JENKINS_URL = 'https://jenkins-test.com'
JOB_NAME = 'myLSF/PriorityAccess'
USERNAME = 'j028232'
API_TOKEN = 'YOUR_JENKINS_API_TOKEN'

def trigger_jenkins_job(approved_requests, category):
    try:
        # Prepare Jenkins parameters dynamically based on category
        if category == 'QUEUE':
            jenkins_params = {
                'REQUEST_ID': approved_requests.get("REQUEST_ID"),
                'CLUSTER_NAME': approved_requests.get('CLUSTER_NAME'),
                'GROUP_AID': approved_requests.get('GROUP_AID'),
                'ACCESS_END_DATE': approved_requests.get('ACCESS_END_DATE'),
                'APPROVED_BY': approved_requests.get('APPROVED_BY'),
                'REQUESTOR_AID': approved_requests.get('USER_AID'),
                'PROJECT_NAME': approved_requests.get('PROJECT_NAME'),
            }
        elif category == 'SLOT':
            jenkins_params = {
                'REQUEST_ID': approved_requests.get("REQUEST_ID"),
                'PROJECT_NAME': approved_requests.get('PROJECT_NAME'),
                'SLOT_TYPE': approved_requests.get('SLOT_TYPE'),
                'CURRENT_SLOT_LIMIT': approved_requests.get('CURRENT_SLOT_LIMIT'),
                'CLUSTER_NAME': approved_requests.get('CLUSTER_NAME'),
                'REQUESTED_SLOT': approved_requests.get('REQUESTED_SLOT'),
                'ACCESS_END_DATE': approved_requests.get('ACCESS_END_DATE'),
                'APPROVED_BY': approved_requests.get('APPROVED_BY'),
                'REQUESTOR_AID': approved_requests.get('USER_AID'),
            }
        else:
            raise ValueError("Invalid CATEGORY_NAME for Jenkins trigger")

        # Trigger Jenkins Build
        trigger_url = f"{JENKINS_URL}/job/{JOB_NAME}/buildWithParameters"
        response = requests.post(
            trigger_url,
            params=jenkins_params,
            auth=(USERNAME, API_TOKEN)
        )

        if response.status_code != 201:
            raise Exception(f"Failed to trigger Jenkins job. Status Code: {response.status_code}, Response: {response.text}")

        print(f"Jenkins build triggered successfully for REQUEST_ID {approved_requests.get('REQUEST_ID')}")

        # Poll for build status
        build_status = poll_jenkins_build_status()
        return build_status

    except Exception as e:
        print(f"Error triggering Jenkins job: {str(e)}")
        return {"error": str(e)}

def poll_jenkins_build_status():
    """Polls the status of the last Jenkins build."""
    try:
        last_build_url = f"{JENKINS_URL}/job/{JOB_NAME}/lastBuild/api/json"

        print("Polling for Jenkins build status...")
        while True:
            response = requests.get(last_build_url, auth=(USERNAME, API_TOKEN))
            if response.status_code != 200:
                raise Exception(f"Failed to fetch build status. Status Code: {response.status_code}, Response: {response.text}")

            build_data = response.json()
            build_result = build_data.get('result')
            if build_result:  # Build is completed
                print(f"Build completed with status: {build_result}")
                return {"status": build_result}
            else:
                print("Build still running... Checking again in 5 seconds.")
                sleep(5)

    except Exception as e:
        print(f"Error polling Jenkins build status: {str(e)}")
        return {"error": str(e)}


---

How It Works

1. Trigger Build:

Sends a POST request to Jenkins using the buildWithParameters endpoint.

Authenticates with Basic Authentication (username + API token).



2. Poll Build Status:

Periodically sends a GET request to lastBuild/api/json to check the build status.

Polls every 5 seconds until the build result is available (SUCCESS, FAILURE, etc.).



3. Build Results:

If the build succeeds, it returns SUCCESS.

If the build fails, it returns FAILURE.





---

Integration into admin_action_request

After triggering the Jenkins job, you can use the returned build result to update the database:

for request_data in data:
    if request_data.get('action') == 'APPROVED':
        additional_data = fetch_additional_data(request_data['REQUEST_ID'], request_data['CATEGORY_NAME'])
        build_result = trigger_jenkins_job(additional_data, request_data['CATEGORY_NAME'])

        # Update database with build result
        request_status = "SUCCESS" if build_result['status'] == 'SUCCESS' else "FAILURE"
        update_status_query = f"""
        UPDATE {dbCfg['QUEUE_ACCESS'] if request_data['CATEGORY_NAME'] == 'QUEUE' else dbCfg['SLOT_REQUEST']}
        SET REQUEST_STATUS = :REQUEST_STATUS
        WHERE REQUEST_ID = :REQUEST_ID
        """
        cursor.execute(update_status_query, {
            "REQUEST_STATUS": request_status,
            "REQUEST_ID": request_data['REQUEST_ID'],
        })


---

Jenkins API Notes

1. Authentication:

Use a username and API token instead of passwords for secure access.

You can generate an API token in Jenkins under:
User > Configure > API Token.



2. Build Status Check:

Use /job/<job-name>/lastBuild/api/json to get the details of the last build.





---

Benefits of This Approach

1. No dependency on external libraries like the Jenkins Python API.


2. Simple REST-based interaction using requests.


3. Continuous polling ensures the build status is captured accurately.


4. Dynamic handling for different categories ensures clean integration.



