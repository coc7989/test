To handle fetching additional data dynamically based on the chosen CATEGORY_NAME (QUEUE or SLOT), we need to update the fetch_additional_data function to work with the appropriate database table and columns. Here's how you can do it:


---

Updated fetch_additional_data Function

1. Dynamic Query Based on Category: Modify the function to check the CATEGORY_NAME and use the corresponding table and column set (QUEUE_ACCESS or SLOT_REQUEST).


2. Implementation:

def fetch_additional_data(REQUEST_ID, CATEGORY_NAME):
    try:
        # Determine the table and columns based on CATEGORY_NAME
        if CATEGORY_NAME == 'QUEUE':
            table_name = dbCfg['QUEUE_ACCESS']
            columns = [
                "REQUEST_ID", "CLUSTER_NAME", "GROUP_AID", "TO_CHAR(ACCESS_END_DATE, 'DD/MM/YYYY') AS ACCESS_END_DATE",
                "APPROVED_BY", "PROJECT_NAME", "USER_AID", "QUEUE", "CPU", "JOBS", "MEMORY", "RUN_TIME", "LSB_OPTION"
            ]
        elif CATEGORY_NAME == 'SLOT':
            table_name = dbCfg['SLOT_REQUEST']
            columns = [
                "REQUEST_ID", "PROJECT_NAME", "SLOT_TYPE", "CURRENT_SLOT_LIMIT",
                "CLUSTER_NAME", "REQUESTED_SLOT", "ACCESS_END_DATE", "APPROVED_BY", "USER_AID"
            ]
        else:
            raise ValueError("Invalid CATEGORY_NAME")

        # Create the query dynamically
        query = f"SELECT {', '.join(columns)} FROM {table_name} WHERE REQUEST_ID = :REQUEST_ID"

        # Execute the query
        db = get_db()
        cursor = db.cursor()
        cursor.execute(query, REQUEST_ID=REQUEST_ID)
        row = cursor.fetchone()
        cursor.close()

        # Map the fetched data to a dictionary
        if row:
            column_names = [col.split(" AS ")[-1] for col in columns]  # Get final column names after aliasing
            additional_data = {column_names[i]: row[i] for i in range(len(column_names))}
            print(additional_data, 'Fetched Additional Data')
            return additional_data
        else:
            return {}

    except Exception as e:
        print(f"Error fetching additional data for REQUEST_ID: {REQUEST_ID}. Error: {str(e)}")
        return {}




---

Changes in Jenkins Job Trigger:

Update the trigger_jenkins_job function to dynamically fetch additional data based on the category.

1. Updated Call to fetch_additional_data: Use CATEGORY_NAME from the request to fetch additional data dynamically.

for request_data in data:
    if request_data.get('action') == 'APPROVED':
        additional_data = fetch_additional_data(request_data['REQUEST_ID'], request_data['CATEGORY_NAME'])
        result, status_code = trigger_jenkins_job(additional_data, request_data['CATEGORY_NAME'])


2. Pass CATEGORY_NAME to Jenkins Parameters: Include the category in the Jenkins job parameters to handle specific logic.

def trigger_jenkins_job(approved_requests, category):
    try:
        print(approved_requests, 'Approved Requests')

        # Prepare Jenkins parameters dynamically
        if category == 'QUEUE':
            jenkins_params = {
                'REQUEST_ID': approved_requests.get("REQUEST_ID"),
                'CLUSTER_NAME': approved_requests.get('CLUSTER_NAME'),
                'GROUP_AID': approved_requests.get('GROUP_AID'),
                'ACCESS_END_DATE': approved_requests.get('ACCESS_END_DATE'),
                'APPROVED_BY': approved_requests.get('APPROVED_BY'),
                'REQUESTOR_AID': approved_requests.get('USER_AID'),
                'PROJECT_NAME': approved_requests.get('PROJECT_NAME'),
                'QUEUE': approved_requests.get('QUEUE'),
                'CPU': approved_requests.get('CPU'),
                'JOBS': approved_requests.get('JOBS'),
                'MEMORY': approved_requests.get('MEMORY'),
                'RUN_TIME': approved_requests.get('RUN_TIME'),
                'LSB_OPTION': approved_requests.get('LSB_OPTION'),
            }
        elif category == 'SLOT':
            jenkins_params = {
                'REQUEST_ID': approved_requests.get("REQUEST_ID"),
                'PROJECT_NAME': approved_requests.get('PROJECT_NAME'),
                'SLOT_TYPE': approved_requests.get('SLOT_TYPE'),
                'CURRENT_SLOT_LIMIT': approved_requests.get('CURRENT_SLOT_LIMIT'),
                'CLUSTER_NAME': approved_requests.get('CLUSTER_NAME'),
                'REQUESTED_SLOT': approved_requests.get('REQUESTED_SLOT'),
                'ACCESS_END_DATE': approved_requests.get('ACCESS_END_DATE'),
                'APPROVED_BY': approved_requests.get('APPROVED_BY'),
                'REQUESTOR_AID': approved_requests.get('USER_AID'),
            }
        else:
            raise ValueError("Invalid category for Jenkins trigger")

        print(jenkins_params, 'Jenkins Parameters')

        # Trigger Jenkins job
        server1 = jenkins.Jenkins('https://jenkins-test.com', username='j028232', password='adda8d9adaha')
        jobname = 'myLSF/PriorityAccess'
        build_info = server1.build_job(jobname, parameters=jenkins_params)

        return {'message': 'Jenkins job triggered successfully'}, 200
    except JenkinsException as je:
        return {'error': f"Jenkins error: {str(je)}"}, 500
    except Exception as e:
        return {'error': f"Unexpected error: {str(e)}"}, 500




---

Benefits of the Approach:

1. Dynamic Query Selection: Adjusts based on the category to fetch relevant data.


2. Category-Specific Jenkins Parameters: Ensures only valid parameters for QUEUE or SLOT categories are sent to Jenkins.


3. Scalable: Easily extendable if more categories are added in the future.



This structure cleanly separates the logic for different categories, minimizing duplication and making the code maintainable.

