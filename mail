Hereâ€™s the updated backend code to handle the scenario where you send only the REQUEST_ID and CATEGORY_NAME from the frontend. The backend will fetch the row data from an Oracle database based on the CATEGORY_NAME (to choose the correct table) and REQUEST_ID.


---

Flask Backend Code

from flask import Flask, request, jsonify
import cx_Oracle  # Oracle DB module
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

app = Flask(__name__)

# Database connection details
ORACLE_DSN = cx_Oracle.makedsn("db_host", "db_port", service_name="db_service_name")
DB_USERNAME = "db_user"
DB_PASSWORD = "db_password"

def fetch_row_data(category_name, request_id):
    """
    Fetch row data from the Oracle database based on CATEGORY_NAME and REQUEST_ID.
    """
    table_name = "QUEUE_TABLE" if category_name.lower() == "queue" else "SLOT_TABLE"
    query = f"""
        SELECT REQUEST_ID, CATEGORY_NAME, PROJECT, ACCESS_END_DATE, SUBMISSION_DATE
        FROM {table_name}
        WHERE REQUEST_ID = :request_id
    """

    try:
        with cx_Oracle.connect(DB_USERNAME, DB_PASSWORD, ORACLE_DSN) as connection:
            with connection.cursor() as cursor:
                cursor.execute(query, request_id=request_id)
                row = cursor.fetchone()

                if row:
                    return {
                        "REQUEST_ID": row[0],
                        "CATEGORY_NAME": row[1],
                        "PROJECT": row[2],
                        "ACCESS_END_DATE": row[3].strftime("%Y-%m-%d") if row[3] else None,
                        "SUBMISSION_DATE": row[4].strftime("%Y-%m-%d") if row[4] else None,
                    }
                else:
                    return None
    except Exception as e:
        raise Exception(f"Database error: {e}")

def send_email_no_auth(to_email, cc_email, subject, row_data):
    """
    Sends an email using the system's SMTP relay without authentication.
    """
    try:
        from_email = "noreply@example.com"  # Change this to your desired 'From' address
        recipients = [to_email] + ([cc_email] if cc_email else [])

        # Convert row data into an HTML table
        table_rows = ''.join(f"<tr><td>{key}</td><td>{value}</td></tr>" for key, value in row_data.items())
        email_body = f"""
        <p>As per user request, the following request has been extended to 15 days:</p>
        <table border="1">
            <tr>
                <th>Field</th>
                <th>Value</th>
            </tr>
            {table_rows}
        </table>
        """

        # Construct the email
        message = MIMEMultipart()
        message["From"] = from_email
        message["To"] = to_email
        if cc_email:
            message["Cc"] = cc_email
        message["Subject"] = subject
        message.attach(MIMEText(email_body, "html"))

        # Send the email via localhost SMTP relay
        with smtplib.SMTP("localhost", 25) as server:  # Replace 'localhost' with your SMTP server if different
            server.sendmail(from_email, recipients, message.as_string())
        return {"message": "Email sent successfully"}
    except Exception as e:
        return {"error": str(e)}

@app.route('/send_email', methods=['POST'])
def send_email():
    """
    Flask endpoint to handle email sending requests.
    """
    try:
        data = request.json
        request_id = data.get('request_id')
        category_name = data.get('category_name')
        to_email = data.get('to')
        cc_email = data.get('cc')

        if not request_id or not category_name or not to_email:
            return jsonify({"error": "Missing required fields (request_id, category_name, to)"}), 400

        # Fetch row data from the database
        row_data = fetch_row_data(category_name, request_id)
        if not row_data:
            return jsonify({"error": "No data found for the given REQUEST_ID"}), 404

        # Send email
        subject = "As per user request, the following request has been extended to 15 days"
        result = send_email_no_auth(to_email, cc_email, subject, row_data)

        if "error" in result:
            return jsonify({"error": result["error"]}), 500
        return jsonify(result), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == "__main__":
    app.run(debug=True)


---

Explanation

1. Fetch Row Data:

Based on the CATEGORY_NAME, we select the appropriate table (QUEUE_TABLE or SLOT_TABLE).

Query filters the row using REQUEST_ID.

Converts date fields (ACCESS_END_DATE, SUBMISSION_DATE) to string format.



2. Database Connection:

Use cx_Oracle to connect to the Oracle database.

Update placeholders (db_host, db_port, db_service_name, etc.) with your Oracle database details.



3. Send Email:

Converts the fetched row data into an HTML table for inclusion in the email body.

Uses an SMTP relay (localhost) to send the email without credentials.



4. Flask Endpoint:

Accepts request_id, category_name, to, and optional cc from the frontend.

Returns appropriate HTTP status codes for success, missing data, or errors.





---

Frontend Example

The React frontend will send only the request_id and category_name:

const sendEmail = async (requestId, categoryName, toEmail, ccEmail) => {
  try {
    const emailPayload = {
      request_id: requestId,
      category_name: categoryName,
      to: toEmail,
      cc: ccEmail,
    };

    const response = await apiInstance.post('/send_email', emailPayload);
    console.log('Email sent successfully:', response.data);
  } catch (error) {
    console.error('Error sending email:', error);
  }
};


---

Testing

1. Run Flask:

python app.py


2. Test with curl or Postman:

curl -X POST http://127.0.0.1:5000/send_email \
-H "Content-Type: application/json" \
-d '{
      "request_id": "12345",
      "category_name": "queue",
      "to": "recipient@example.com",
      "cc": "cc-recipient@example.com"
    }'




---

Notes

Ensure the Oracle database is accessible from the server running this Flask app.

Replace placeholders in the database connection settings (db_host, db_user, etc.).

If your SMTP relay is not localhost, update the relay settings accordingly.


