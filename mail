Hereâ€™s the updated SlotChangeForm to incorporate the SLOT_TYPE logic. The current slot limit box will only appear after the user selects a SLOT_TYPE, and it will show a loading spinner until the slot limit is fetched.


---

Updated Frontend React Code

import React, { useContext, useEffect, useState } from 'react';
import { useForm, Controller } from 'react-hook-form';
import { 
  Box, 
  Button, 
  Grid, 
  MenuItem, 
  Paper, 
  Stack, 
  TextField, 
  Typography, 
  CircularProgress 
} from '@mui/material';
import apiInstance from '../../../api';
import { ClusterContext } from '../../../NotificationContext';

const SlotChangeForm = () => {
  const { userID } = useContext(ClusterContext); // Retrieve user ID from context
  const { control, handleSubmit, reset, watch, formState: { errors }, setValue } = useForm({
    mode: 'onChange',
  });

  const slotType = watch('slotType'); // Watch SLOT_TYPE selection
  const [currentSlotLimit, setCurrentSlotLimit] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  // Fetch current slot limit based on SLOT_TYPE and userID
  useEffect(() => {
    const fetchCurrentSlotLimit = async () => {
      if (!slotType) return;

      try {
        setLoading(true);
        setError('');
        const response = await apiInstance.get(`/getSlotLimit?userID=${userID}&slotType=${slotType}`);
        if (response.status === 200) {
          setCurrentSlotLimit(response.data.slotLimit);
        } else {
          throw new Error(response.data.error || 'Failed to fetch slot limit');
        }
      } catch (err) {
        setError(err.message || 'Error fetching slot limit');
      } finally {
        setLoading(false);
      }
    };

    if (userID && slotType) {
      fetchCurrentSlotLimit();
    }
  }, [userID, slotType]);

  const onSubmit = async (data) => {
    try {
      const response = await apiInstance.post('/slotChange', { ...data, userID });
      if (response.status === 200) {
        alert('Slot change request submitted successfully!');
      }
    } catch (error) {
      console.error('Error while submitting:', error);
    }
  };

  return (
    <Paper elevation={24} sx={{ padding: 4 }}>
      <Typography variant="h5" mb={2}>Slot Change Form</Typography>

      {/* Current Slot Limit Box */}
      {slotType && (
        <Box
          sx={{
            border: '1px solid #ccc',
            borderRadius: '8px',
            padding: '16px',
            backgroundColor: '#f9f9f9',
            marginBottom: 3,
          }}
        >
          {loading ? (
            <CircularProgress />
          ) : error ? (
            <Typography color="error">{error}</Typography>
          ) : (
            <Typography variant="h6" color="textSecondary">
              Current Slot Limit for <b>{slotType}</b>:
              <Typography variant="h6" component="span" color="primary" ml={1}>
                {currentSlotLimit}
              </Typography>
            </Typography>
          )}
        </Box>
      )}

      <form onSubmit={handleSubmit(onSubmit)}>
        <Grid container spacing={2}>
          {/* Dropdown for Slot Type */}
          <Grid item xs={12}>
            <Controller
              name="slotType"
              control={control}
              defaultValue=""
              rules={{ required: 'Slot type is required.' }}
              render={({ field }) => (
                <TextField
                  {...field}
                  select
                  label="Slot Type"
                  fullWidth
                  error={!!errors.slotType}
                  helperText={errors.slotType ? errors.slotType.message : 'Select a slot type.'}
                >
                  <MenuItem value="gui">GUI Slot</MenuItem>
                  <MenuItem value="regress">Regress Slot</MenuItem>
                </TextField>
              )}
            />
          </Grid>

          {/* Justification Textbox */}
          <Grid item xs={12}>
            <Controller
              name="justification"
              control={control}
              defaultValue=""
              rules={{ required: 'Justification is required.' }}
              render={({ field }) => (
                <TextField
                  {...field}
                  label="Justification"
                  multiline
                  rows={4}
                  fullWidth
                  error={!!errors.justification}
                  helperText={errors.justification ? errors.justification.message : 'Provide a valid justification.'}
                />
              )}
            />
          </Grid>
        </Grid>

        {/* Buttons */}
        <Stack spacing={2} direction="row" justifyContent="center" mt={3}>
          <Button type="submit" variant="contained" color="primary">
            Submit
          </Button>
          <Button
            type="button"
            variant="contained"
            color="secondary"
            onClick={() => {
              reset();
              setCurrentSlotLimit(null);
              setValue('slotType', '');
              setValue('justification', '');
            }}
          >
            Reset
          </Button>
        </Stack>
      </form>
    </Paper>
  );
};

export default SlotChangeForm;


---

Backend Flask Code

The backend now processes both userID and SLOT_TYPE. The /getSlotLimit endpoint will trigger the Jenkins pipeline with both parameters and respond with the current slot limit.


---

@app.route('/getSlotLimit', methods=['GET'])
def get_slot_limit():
    user_id = request.args.get('userID')
    slot_type = request.args.get('slotType')

    if not user_id or not slot_type:
        return jsonify({"error": "User ID and Slot Type are required"}), 400

    # Trigger Jenkins pipeline
    try:
        response = requests.post(
            JENKINS_URL,
            auth=(JENKINS_USER, JENKINS_TOKEN),
            params={"USER_ID": user_id, "SLOT_TYPE": slot_type},
        )

        if response.status_code == 201:
            # Simulate waiting for Jenkins to return data or check callbacks here
            # Replace this with actual callback handling
            slot_limit = 35  # Mock slot limit
            return jsonify({"slotLimit": slot_limit}), 200
        else:
            return jsonify({"error": "Failed to trigger Jenkins pipeline"}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500


---

Key Updates

1. Frontend:

SLOT_TYPE is watched using react-hook-form's watch method.

The current slot limit box appears only when SLOT_TYPE is selected.

A loading spinner or error message is shown while fetching the slot limit.



2. Backend:

Receives both userID and SLOT_TYPE in the /getSlotLimit endpoint.

Passes these parameters to the Jenkins pipeline.




This ensures the slot limit is dynamically updated based on the selected slot type. Let me know if you need further adjustments!

