To implement similar functionality for editing the REQUEST_STATUS field with a dropdown that offers options COMPLETED, PENDING, and REJECTED, follow these steps:


---

Client-Side Changes

1. Modify the ALL_COLUMNS Definition: Update the ALL_COLUMNS to make the REQUEST_STATUS field editable, just like ACCESS_END_DATE.


2. Dropdown Component for REQUEST_STATUS: Add a dropdown inside the Cell renderer of REQUEST_STATUS column.


3. Handle Changes in REQUEST_STATUS: Define new handlers to manage changes and save actions for REQUEST_STATUS.




---

Updated ALL_COLUMNS

const ALL_COLUMNS = useMemo(
  () => [
    {
      accessorKey: 'REQUEST_ID',
      header: 'REQUEST ID',
      size: 90,
    },
    {
      accessorKey: 'REQUEST_STATUS',
      header: 'REQUEST STATUS',
      size: 150,
      Cell: ({ cell }) => {
        const REQUEST_ID = cell.row.original.REQUEST_ID;
        const value = cell.getValue();
        const currentEdit = editData[REQUEST_ID]?.REQUEST_STATUS;

        return REQUEST === 'EDITABLE' ? (
          <>
            <Select
              value={currentEdit || value}
              onChange={(e) =>
                setEditData((prev) => ({
                  ...prev,
                  [REQUEST_ID]: { ...(prev[REQUEST_ID] || {}), REQUEST_STATUS: e.target.value },
                }))
              }
              size="small"
              fullWidth
            >
              <MenuItem value="COMPLETED">Completed</MenuItem>
              <MenuItem value="PENDING">Pending</MenuItem>
              <MenuItem value="REJECTED">Rejected</MenuItem>
            </Select>
            {currentEdit && currentEdit !== value && (
              <Box display="flex" gap="10px" marginTop="5px">
                <Button
                  variant="contained"
                  size="small"
                  onClick={() => handleSaveStatus(REQUEST_ID)}
                >
                  Save
                </Button>
                <Button
                  variant="outlined"
                  size="small"
                  onClick={() => handleCancel(REQUEST_ID)}
                >
                  Cancel
                </Button>
              </Box>
            )}
          </>
        ) : (
          <Box
            sx={(theme) => ({
              backgroundColor:
                value === 'PENDING'
                  ? '#FFE97F'
                  : value === 'COMPLETED'
                  ? '#85A98F'
                  : '#FFAAA6',
              borderRadius: '4px',
              display: 'inline-block',
              width: '120px',
              textAlign: 'center',
              padding: '4px',
            })}
          >
            <Typography align="center" color="black">
              {value.charAt(0).toUpperCase() + value.slice(1)}
            </Typography>
          </Box>
        );
      },
    },
  ],
  [REQUEST, editData]
);


---

New Handlers for REQUEST_STATUS

const handleSaveStatus = (REQUEST_ID) => {
  const REQUEST_STATUS = editData[REQUEST_ID]?.REQUEST_STATUS;
  if (REQUEST_STATUS) {
    setOpen(true);
    mutationStatus.mutate({ REQUEST_ID, REQUEST_STATUS });
  }
};


---

Server-Side Changes

1. Update Endpoint: Update your server endpoint to accept and process REQUEST_STATUS in addition to ACCESS_END_DATE.



Backend Endpoint Update

data = request.get_json()
request_id = data.get('REQUEST_ID')
access_end_date = data.get('ACCESS_END_DATE')
request_status = data.get('REQUEST_STATUS')

print("request_id", request_id)
print("access_end_date", access_end_date)
print("request_status", request_status)

if not request_id or (not access_end_date and not request_status):
    return jsonify({'error': 'REQUEST_ID and at least one of ACCESS_END_DATE or REQUEST_STATUS are required'}), 400

db = get_db()
cursor = db.cursor()

try:
    if access_end_date:
        update_query_date = f"""
            UPDATE {dbCfg['QUEUE_ACCESS']}
            SET ACCESS_END_DATE = TO_DATE(:access_end_date, 'YYYY-MM-DD')
            WHERE REQUEST_ID = :request_id
        """
        cursor.execute(update_query_date, {'access_end_date': access_end_date, 'request_id': request_id})

    if request_status:
        update_query_status = f"""
            UPDATE {dbCfg['QUEUE_ACCESS']}
            SET REQUEST_STATUS = :request_status
            WHERE REQUEST_ID = :request_id
        """
        cursor.execute(update_query_status, {'request_status': request_status, 'request_id': request_id})

    db.commit()
    cursor.close()
    return jsonify({'message': 'Data updated successfully'}), 200

except cx_Oracle.DatabaseError as e:
    error, = e.args
    print("error", f"Database error: {error.message}")
    return jsonify({'error': f"Database error: {error.message}"}), 500
except Exception as e:
    print("error", str(e))
    return jsonify({'error': str(e)}), 500


---

With these changes, you will have an editable REQUEST_STATUS field using a dropdown, with updates reflected both on the client and server.

