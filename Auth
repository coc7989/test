Hereâ€™s an updated version of your frontend and backend code to handle rejection reasons and ensure that the processed date is fetched on the backend instead of the frontend.


---

Frontend Updates

Changes:

1. Reject Button: Now opens a dialog box where the admin can enter a rejection reason.


2. handleClick Function: Modified to include rejectionReason when the action is 'REJECTED'.


3. Dialog Component: Added to take the rejection reason input.



import { useState } from 'react';
import { Button, Dialog, DialogActions, DialogContent, DialogTitle, TextField } from '@mui/material';

const [openDialog, setOpenDialog] = useState(false);
const [rejectionReason, setRejectionReason] = useState('');
const [selectedRow, setSelectedRow] = useState(null);

const handleRejectClick = (row) => {
    setSelectedRow(row);
    setOpenDialog(true);
};

const handleDialogClose = () => {
    setOpenDialog(false);
    setRejectionReason('');
};

const handleConfirmReject = async () => {
    if (!rejectionReason.trim()) {
        alert("Rejection reason is required!");
        return;
    }
    setOpenDialog(false);
    await handleClick(selectedRow, 'REJECTED', rejectionReason);
};

const handleClick = async (row, action, reason = null) => {
    setOpen(true);
    console.log('row.original', row.original);

    const { REQUEST_ID, CATEGORY_NAME, REQUEST_TYPE, ...otherProps } = row.original;

    const rowData = {
        REQUEST_ID,
        ADMIN_APPROVAL: userID,
        CATEGORY_NAME,
        REQUEST_TYPE,
        action,
        rejectionReason: reason  // Adding rejection reason if rejected
    };

    console.log([rowData], 'rows log');

    try {
        const response = await apiInstance.put('/admin_panel_requests', [rowData]);
        console.log(response, 'handleClick response');

        if (response.status === 200) {
            await refetch();
            setOpen(false);
        }
    } catch (error) {
        console.error('Update Failed:', error);
    }
};

const renderRowButtons = ({ table, row }) => (
    <Grid2 textAlign={'center'} justifyContent="center" alignItems="center">
        <Button
            size="large"
            sx={{ mx: 1 }}
            color="success"
            disabled={table.getSelectedRowModel().flatRows.length > 1}
            onClick={() => handleClick(row, 'APPROVED')}
            variant="contained"
        >
            Approve
        </Button>
        <Button
            size="large"
            color="error"
            disabled={table.getSelectedRowModel().flatRows.length > 1}
            onClick={() => handleRejectClick(row)}
            variant="contained"
        >
            Reject
        </Button>

        {/* Dialog Box for Rejection Reason */}
        <Dialog open={openDialog} onClose={handleDialogClose}>
            <DialogTitle>Enter Rejection Reason</DialogTitle>
            <DialogContent>
                <TextField
                    autoFocus
                    margin="dense"
                    label="Rejection Reason"
                    fullWidth
                    multiline
                    rows={3}
                    value={rejectionReason}
                    onChange={(e) => setRejectionReason(e.target.value)}
                />
            </DialogContent>
            <DialogActions>
                <Button onClick={handleDialogClose} color="primary">
                    Cancel
                </Button>
                <Button onClick={handleConfirmReject} color="error">
                    Confirm Reject
                </Button>
            </DialogActions>
        </Dialog>
    </Grid2>
);


---

Backend Updates

Changes:

1. Fetch UPDATED_DATE on Backend: Replaced PROCESSED_DATE with sysdate to avoid fetching it on the frontend.


2. Handle Rejection Reason: Added REJECTION_REASON column update in case of rejection.



elif request.method == 'PUT':
    try:
        query_queue = f"""
        UPDATE {dbCfg['QUEUE_ACCESS']}
        SET UPDATED_DATE = sysdate,  -- Fetching from backend
            REQUEST_STATUS = :REQUEST_STATUS,
            APPROVED_BY = :ADMIN_APPROVAL,
            ACCESS_END_DATE = TO_DATE(:ACCESS_END_DATE, 'YYYY-MM-DD'),
            REJECTION_REASON = :REJECTION_REASON  -- Adding rejection reason
        WHERE REQUEST_ID = :REQUEST_ID
        """

        query_slot = f"""
        UPDATE {dbCfg['SLOT_REQUEST']}
        SET UPDATED_DATE = sysdate,  -- Fetching from backend
            REQUEST_STATUS = :REQUEST_STATUS,
            APPROVED_BY = :ADMIN_APPROVAL,
            REJECTION_REASON = :REJECTION_REASON  -- Adding rejection reason
        WHERE REQUEST_ID = :REQUEST_ID
        """

        data = request.json
        print("Data from frontend:", data)
        params = []

        for item in data:
            category = item.get('CATEGORY_NAME')
            rejection_reason = item.get('rejectionReason', None)

            if category == 'QUEUE':
                if item['REQUEST_TYPE'] in ['priority', 'hwsim']:
                    access_end_date = calculate_access_end_date(item['PROCESSED_DATE'], item['action'])
                    print("Access end date:", access_end_date)
                else:
                    raise ValueError("Invalid REQUEST_TYPE for QUEUE category")

                params.append({
                    "REQUEST_ID": item['REQUEST_ID'],
                    "ADMIN_APPROVAL": item['ADMIN_APPROVAL'],
                    "REQUEST_STATUS": item['action'],
                    "ACCESS_END_DATE": access_end_date,
                    "REJECTION_REASON": rejection_reason,
                })

            elif category == 'SLOT':
                if item['REQUEST_TYPE'] in ['gui', 'regress']:
                    params.append({
                        "REQUEST_ID": item['REQUEST_ID'],
                        "ADMIN_APPROVAL": item['ADMIN_APPROVAL'],
                        "REQUEST_STATUS": item['action'],
                        "REJECTION_REASON": rejection_reason,
                    })
                else:
                    raise ValueError("Invalid REQUEST_TYPE for SLOT category")

        db = get_db()
        cursor = db.cursor()

        if category == 'QUEUE':
            cursor.executemany(query_queue, params)
            print("Queue data updated successfully")
        elif category == 'SLOT':
            cursor.executemany(query_slot, params)
            print("Slot data updated successfully")

        db.commit()
        return jsonify({'message': "Request updated successfully"}), 200

    except Exception as e:
        print(f"An error occurred: {str(e)}")
        return jsonify({'error': str(e)})
    finally:
        cursor.close()


---

Summary of Changes

1. Frontend:

Added a dialog box for entering rejection reasons.

Passed the rejection reason to handleClick.

Ensured PROCESSED_DATE is no longer generated on the frontend.



2. Backend:

Used sysdate for UPDATED_DATE to ensure the date is fetched in the backend.

Stored REJECTION_REASON in the database when an admin rejects a request.




This implementation ensures that admins must enter a rejection reason, and all important data (like timestamps) is handled securely on the backend. Let me know if you need any further modifications!

