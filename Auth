To enhance your backend and frontend as described ‚Äî fetching the ACCESS_END_DATE from a second table only when the current slot limit is found in the first table ‚Äî here's how you can implement it:


---

‚úÖ Backend Update

Add logic to fetch ACCESS_END_DATE from SLOT_REQUEST table using the given conditions.

üîÅ Updated Backend Code (get_current_slot_limit)

@app.route(f"{API_URL_PREFIX}/get_current_slot_limit", methods=['GET'])
@cross_origin()
def get_current_slot_limit():
    user_id = request.args.get('userID')
    slot_type = request.args.get('SLOT_TYPE')
    cluster_name = request.args.get('CLUSTER_NAME')
    request_id = str(uuid.uuid4())
    
    slot_limit_table = dbCfg['CURRENT_SLOT_LIMIT_TBL']
    slot_request_table = dbCfg['SLOT_REQUEST']
    
    try:
        conn = get_oracle_connection()
        cursor = conn.cursor()
        
        # Step 1: Fetch current slot limit
        query_slot_limit = f"""
            SELECT CURRENT_SLOT_LIMIT FROM {slot_limit_table}
            WHERE USERID = :user_id
              AND SLOT_TYPE = :slot_type
              AND CLUSTER_NAME = :cluster_name
        """
        cursor.execute(query_slot_limit, {
            "user_id": user_id,
            "slot_type": slot_type,
            "cluster_name": cluster_name
        })
        result = cursor.fetchone()
        
        if result:
            current_slot_limit = int(result[0])
            access_end_date = None

            # Step 2: Fetch access end date from SLOT_REQUEST table
            query_access_end = f"""
                SELECT ACCESS_END_DATE FROM {slot_request_table}
                WHERE USERID = :user_id
                  AND SLOT_TYPE = :slot_type
                  AND CLUSTER_NAME = :cluster_name
                  AND REQUEST_STATUS = 'COMPLETED'
                  AND REQUESTED_SLOT_LIMIT = :current_slot_limit
                ORDER BY ACCESS_END_DATE DESC FETCH FIRST 1 ROWS ONLY
            """
            cursor.execute(query_access_end, {
                "user_id": user_id,
                "slot_type": slot_type,
                "cluster_name": cluster_name,
                "current_slot_limit": current_slot_limit
            })
            access_result = cursor.fetchone()
            if access_result:
                access_end_date = access_result[0]  # Assumes it's a datetime/date object

        else:
            slot_key = f"{slot_type.lower()}-default-slot-limit"
            if slot_key in config_data and cluster_name in config_data[slot_key]:
                current_slot_limit = config_data[slot_key][cluster_name]
                access_end_date = None
            else:
                return jsonify({'error_message': 'No slot limit data found in DB or config'}), 500
        
        return jsonify({
            "user_id": user_id,
            "slot_type": slot_type,
            "cluster_name": cluster_name,
            "current_slot_limit": current_slot_limit,
            "access_end_date": access_end_date,
            "request_id": request_id
        }), 200
    except Exception as e:
        print("Oracle DB error:", traceback.format_exc())
        return jsonify({'error_message': 'Internal server error occurred while fetching slot limit'}), 500


---

‚úÖ Frontend Update

Update your UI to display the ACCESS_END_DATE if it's available.

üîÅ Changes in JSX

Update your React component like this:

<Typography>
  Current Slot Limit for <b>{SLOT_TYPE}</b>:{' '}
  <Typography component="span" color="primary" fontWeight="bold">
    {currentSlotLimit}
  </Typography>
  {accessEndDate && (
    <>
      {' '} (Ending on:{' '}
      <Typography component="span" color="secondary" fontWeight="bold">
        {new Date(accessEndDate).toLocaleDateString()}
      </Typography>
      )
    </>
  )}
</Typography>

‚úÖ Also update state variables:

Ensure you‚Äôre saving accessEndDate from API:

const [accessEndDate, setAccessEndDate] = useState(null);

useEffect(() => {
  const fetchLimit = async () => {
    setLoading(true);
    setError('');
    try {
      const response = await apiInstance.get('/get_current_slot_limit', {
        params: { userID, SLOT_TYPE, CLUSTER_NAME: clusterName },
      });
      setCurrentSlotLimit(response.data.current_slot_limit);
      setAccessEndDate(response.data.access_end_date);  // <-- new line
      setRequestId(response.data.request_id);
    } catch (error) {
      setError('Failed to fetch slot limit');
    } finally {
      setLoading(false);
    }
  };
  fetchLimit();
}, [userID, SLOT_TYPE, clusterName]);


---

‚úÖ Summary

You added logic in the backend to optionally fetch ACCESS_END_DATE when a CURRENT_SLOT_LIMIT exists.

You send this value to the frontend.

You updated the frontend to show "Ending on: {date}" if the date exists.


Let me know if you want to format the date differently or handle time zones!

