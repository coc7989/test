yTo create a very detailed flowchart of your updated code, I will:

1. Summarize the major functional blocks and logic flow.


2. Map out control flows: startup, data loading, job filtering, scoring, moving.


3. Highlight decisions, loops, and database interactions.


4. Deliver a structured flowchart in textual format first (for clarity), and optionally generate a diagram (in a follow-up if you're using a chat that supports image generation).




---

ğŸ§­ HIGH-LEVEL OVERVIEW

This script is a job migration engine for LSF clusters. It analyzes queued jobs, scores them based on various intelligence metrics, and selectively migrates them from high-load queues (like normal) to backup queues (regress, flexi) while recording history in an Oracle database.


---

ğŸ§± FLOWCHART BLOCKS (STRUCTURED LOGIC)

Below is a step-by-step flowchart-style breakdown of the code:


---

ğŸŸ¢ STARTUP

Load environment variables (using dotenv)

Initialize constants:

ENVIRONMENT, CLUSTER_NAME, CYCLE_ID, etc.

INTELLIGENCE_SCORES_CAP â† ast.literal_eval(...)

DEFAULT_QUEUE_QUOTAS â† ast.literal_eval(...)




---

ğŸ”¶ MAIN FUNCTION ENTRYPOINT

def main()

â¬…ï¸ Parse CLI arguments (--dry-run, --disable-*)

ğŸ“„ Load priority_users, priority_projects from YAML files

ğŸ“Š Call get_cluster_slots() to get total and running slots

â— Check if cluster is too full (based on BUFFER_THRESHOLD_RATIO)

âŒ If too full â†’ Abort


ğŸ” Call parse_mbjobs2() to fetch and optionally move jobs

Returns: list of jobs that were not auto-moved




---

ğŸ§± parse_mbjobs2() - PENDING JOB FILTERING

Run mbjobs2 command to get pending jobs in desired queues

For each job:

ğŸ“Œ Extract job metadata

ğŸ“¤ Check if it can be auto-moved (via should_move_job)

âœ… If yes â†’ attempt_move_job() and record move

âŒ Else â†’ Add job to return list



ğŸ” Returns list of jobs that need scoring



---

ğŸ§  should_move_job(job, quota_cache)

ğŸ§¾ Check job queue = normal

ğŸ“¦ Check if job already moved (via DB)

ğŸ“Š Get quota/usage for normal and regress queues (cached or fresh)

âœ… If quota exhausted in normal and space in regress, return True



---

ğŸ—ï¸ attempt_move_job(job)

ğŸ› ï¸ Call move_job(job) (dry-run or actual bmod)

ğŸ“ Record the move in DB (record_job_move)

ğŸ”„ Update quota_cache for that user and queue



---

ğŸ§  score_job(job, ...) - INTELLIGENCE SCORING ENGINE

For each job:

Initialize score = 0, rules = []

Apply score if feature not disabled:

ğŸ¯ project_priority

ğŸ‘¤ user_priority

ğŸ“ default_quota_sort

ğŸ•’ pending_age (scaled)

ğŸ§® user_utilization (from Oracle DB)

âš™ï¸ avg_efficiency (from Oracle DB)

ğŸ¢ long_pending


ğŸ” Return final score and rules_applied



---

ğŸ§ª After scoring:

Back in main():

Filter jobs whose usage < quota or already moved

Call score_job() â†’ collect (score, job, rules)

Sort by score descending

For each job:

ğŸ“¦ If job would exceed FLEXI_QUEUE_CAP, skip

â— If cluster is full or job too big, skip

ğŸ› ï¸ Call move_job(job)

ğŸ“ Record move in DB

â• Add to moved_slots




---

ğŸ”š END


---

ğŸ”„ FUNCTION INTERACTIONS

main()
â”œâ”€â”€ load_priority_config()
â”œâ”€â”€ get_cluster_slots()
â”œâ”€â”€ parse_mbjobs2()
â”‚   â”œâ”€â”€ run_cmd("mbjobs2")
â”‚   â”œâ”€â”€ should_move_job()
â”‚   â”‚   â”œâ”€â”€ is_job_already_moved()
â”‚   â”‚   â””â”€â”€ get_user_queue_limits()
â”‚   â””â”€â”€ attempt_move_job()
â”‚       â”œâ”€â”€ move_job()
â”‚       â””â”€â”€ record_job_move()
â”œâ”€â”€ score_job()
â”‚   â”œâ”€â”€ get_user_utilization()
â”‚   â””â”€â”€ get_user_avg_efficiency()
â””â”€â”€ move_job()  [again, for scored jobs]


---

ğŸ—ƒï¸ DATABASE USAGE SUMMARY

Function	Purpose	Query

get_user_utilization()	Yesterday's CPU*runtime	SUM(NUM_PROC * RUN_TIME)
get_user_avg_efficiency()	Yesterday's avg efficiency	AVG(JOB_EFF)
is_job_already_moved()	Avoid duplicate migrations	SELECT 1 FROM JOB_MOVE_HISTORY
record_job_move()	Log move event	INSERT INTO JOB_MOVE_HISTORY



---

ğŸ› ï¸ NEXT STEPS

If you'd like:

I can convert this logic into a visual diagram (flowchart) if you're in a chat that supports image generation.

Or provide a Mermaid.js diagram for rendering in Markdown or documentation.

Or generate a PDF flowchart for documentation use.


Would you like the visual version of this flow? If yes, let me know the format you prefer (image, Mermaid, or both).

