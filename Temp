Great! Here's how you can update your code to support the cluster dropdown, use the default cluster from context, and dynamically fetch data based on the selected cluster.


---

1. Update AdminPanel.js

Add a dropdown for selecting clusters and manage the selected cluster state.

import { MenuItem, Select, InputLabel, FormControl } from '@mui/material';
import { useContext, useEffect, useState } from 'react';
// ...

const AdminPanel = () => {
  const [alignment, setAlignment] = useState('PENDING');
  const { defaultCluster } = useContext(ClusterContext); // from context
  const [selectedCluster, setSelectedCluster] = useState(defaultCluster);
  const containerRef = useRef(null);

  useEffect(() => {
    setSelectedCluster(defaultCluster);
  }, [defaultCluster]);

  const handleClusterChange = (event) => {
    setSelectedCluster(event.target.value);
  };

  return (
    <Container maxWidth="xl">
      <Paper elevation={1} sx={{ backgroundColor: '#f2ebfb', p: 2 }}>
        <Grid container xs={12} direction="row" justifyContent="space-between" alignItems="center">
          <Grid>
            <FormControl>
              <InputLabel>Select Cluster</InputLabel>
              <Select value={selectedCluster} onChange={handleClusterChange} label="Select Cluster">
                <MenuItem value="cluster1">Cluster 1</MenuItem>
                <MenuItem value="cluster2">Cluster 2</MenuItem>
                {/* Add more clusters as needed */}
              </Select>
            </FormControl>
          </Grid>
          <Grid xs={12} textAlign={'center'}>
            <Tabs
              centered
              value={alignment}
              onChange={(e, newValue) => setAlignment(newValue)}
              textColor="primary"
              indicatorColor="primary"
            >
              <Tab sx={{ fontSize: '18px' }} value="PENDING" label="PENDING FOR APPROVAL" />
              <Tab sx={{ fontSize: '18px' }} value="COMPLETED" label="COMPLETED" />
            </Tabs>
          </Grid>

          <Grid xs={12} ref={containerRef}>
            {alignment === 'PENDING' && (
              <Slide direction="right" in timeout={200} container={containerRef.current}>
                <Card sx={{ mt: 1 }}>
                  <AdminRequestPanel REQUEST_STATUS="PENDING" clusterName={selectedCluster} />
                </Card>
              </Slide>
            )}
            {alignment === 'COMPLETED' && (
              <Slide direction="left" in timeout={200} container={containerRef.current}>
                <Grid2 xs={12} sx={{ mt: 1 }}>
                  <AdminRequestPanel REQUEST_STATUS="COMPLETED" clusterName={selectedCluster} />
                </Grid2>
              </Slide>
            )}
          </Grid>
        </Grid>
      </Paper>
    </Container>
  );
};


---

2. Update AdminRequestPanel.js

Accept clusterName as a prop and include it in your API call.

const AdminRequestPanel = ({ REQUEST_STATUS, clusterName }) => {
  // ...

  const fetchAccessRequests = async (userID, REQUEST_STATUS, clusterName) => {
    const res = await apiInstance.get(
      `/admin_panel_requests?userID=${userID}&REQUEST_STATUS=${REQUEST_STATUS}&clusterName=${clusterName}`
    );
    return res.data || {};
  };

  const {
    data,
    isLoading,
    refetch,
  } = useQuery(
    ['accessRequests', userID, REQUEST_STATUS, clusterName],
    () => fetchAccessRequests(userID, REQUEST_STATUS, clusterName),
    {}
  );

  useEffect(() => {
    refetch();
  }, [REQUEST_STATUS, clusterName]); // refetch on status or cluster change

  // ...
};


---

3. Update main.py backend

Update your Flask endpoint to read the clusterName from the query string.

userID = request.args.get('userID')
REQUEST_STATUS = request.args.get('REQUEST_STATUS')
site_name = request.args.get('clusterName')  # Now taken from frontend instead of context mapping

You can optionally fall back to the mapping if clusterName is not passed.


---

Let me know if you want to dynamically populate the cluster list as well (e.g. from backend via API).

