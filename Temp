To set up a multi-branch pipeline for both frontend and backend containers, I'll outline the Dockerfile and Jenkinsfile for each. This setup will allow Jenkins to build different branches and deploy both dev and stage environments.

Frontend Dockerfile (Dockerfile.frontend)

# Use a Node.js base image
FROM node:16 AS build

# Set working directory
WORKDIR /app

# Copy package files and install dependencies
COPY package*.json ./
RUN npm install

# Copy the entire frontend source code
COPY . .

# Build the frontend
RUN npm run build

# Serve with a lightweight server
FROM nginx:alpine
COPY --from=build /app/build /usr/share/nginx/html

# Expose the port
EXPOSE 80

Backend Dockerfile (Dockerfile.backend)

# Use a Python base image
FROM python:3.9-slim

# Set working directory
WORKDIR /app

# Copy requirements file and install dependencies
COPY requirements.txt .
RUN pip install -r requirements.txt

# Copy the entire backend source code
COPY . .

# Expose the API port
EXPOSE 5000

# Run the application
CMD ["python", "app.py"]

Jenkinsfile for Frontend (Jenkinsfile.frontend)

pipeline {
    agent any
    environment {
        DOCKER_IMAGE = "myrepo/frontend:${BRANCH_NAME}"
    }
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        stage('Build Docker Image') {
            steps {
                script {
                    docker.build("${DOCKER_IMAGE}", "-f Dockerfile.frontend .")
                }
            }
        }
        stage('Push Docker Image') {
            steps {
                script {
                    docker.withRegistry('https://registry.hub.docker.com', 'dockerhub-credentials') {
                        docker.image("${DOCKER_IMAGE}").push()
                    }
                }
            }
        }
        stage('Deploy') {
            steps {
                script {
                    if (BRANCH_NAME == 'dev') {
                        sh 'docker run -d --name frontend-dev -p 8080:80 ${DOCKER_IMAGE}'
                    } else if (BRANCH_NAME == 'stage') {
                        sh 'docker run -d --name frontend-stage -p 8081:80 ${DOCKER_IMAGE}'
                    }
                }
            }
        }
    }
    post {
        always {
            script {
                docker.image("${DOCKER_IMAGE}").remove()
            }
        }
    }
}

Jenkinsfile for Backend (Jenkinsfile.backend)

pipeline {
    agent any
    environment {
        DOCKER_IMAGE = "myrepo/backend:${BRANCH_NAME}"
    }
    stages {
        stage('Checkout') {
            steps {
                checkout scm
            }
        }
        stage('Build Docker Image') {
            steps {
                script {
                    docker.build("${DOCKER_IMAGE}", "-f Dockerfile.backend .")
                }
            }
        }
        stage('Push Docker Image') {
            steps {
                script {
                    docker.withRegistry('https://registry.hub.docker.com', 'dockerhub-credentials') {
                        docker.image("${DOCKER_IMAGE}").push()
                    }
                }
            }
        }
        stage('Deploy') {
            steps {
                script {
                    if (BRANCH_NAME == 'dev') {
                        sh 'docker run -d --name backend-dev -p 5000:5000 ${DOCKER_IMAGE}'
                    } else if (BRANCH_NAME == 'stage') {
                        sh 'docker run -d --name backend-stage -p 6000:5000 ${DOCKER_IMAGE}'
                    }
                }
            }
        }
    }
    post {
        always {
            script {
                docker.image("${DOCKER_IMAGE}").remove()
            }
        }
    }
}

Explanation

Dockerfile.frontend and Dockerfile.backend: Each Dockerfile is tailored to build the frontend and backend services, using nginx for the frontend and python for the backend.

Jenkinsfile (frontend and backend):

Checkout: Pulls the code for the current branch.

Build Docker Image: Builds the Docker image and tags it with the branch name.

Push Docker Image: Pushes the built Docker image to Docker Hub (or any other Docker registry).

Deploy: Runs a container based on the branch (dev or stage), mapping the necessary ports.

Post-Stage Cleanup: Removes the Docker image from the local Jenkins environment after the pipeline finishes.



Note: Make sure to:

Replace myrepo/frontend and myrepo/backend with your actual Docker Hub repository.

Configure Docker Hub credentials (dockerhub-credentials) in Jenkins.


