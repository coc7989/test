Your idea of storing the configuration data in a dynamic file in your Flask backend, allowing the frontend to edit it, and using it in Jenkins is solid. However, you need a clear strategy for fetching this data in your pipeline. Here’s how you can implement it efficiently:

Implementation Approach

1. Store Configuration in a JSON/YAML File

Instead of defining the configuration as a Python dictionary, store it in a config.json or config.yaml file in your Flask backend.

Example config.json:

{
  "GUI": {
    "12": "gui_12slots_grp",
    "16": "gui_16slots_grp",
    "32": "gui_32slots_grp",
    "40": "gui_40slots_grp"
  },
  "REGRESS": {
    "500": "regress_500_grp",
    "800": "regress_800_grp"
  }
}



2. Expose an API in Flask to Serve This Data

Create an endpoint in Flask to fetch the configuration:

from flask import Flask, jsonify
import json

app = Flask(__name__)

@app.route('/get-config', methods=['GET'])
def get_config():
    with open('config.json', 'r') as file:
        data = json.load(file)
    return jsonify(data)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)

This allows Jenkins or any other service to fetch the latest config dynamically.



3. Fetch the Configuration in Jenkins Pipeline
In your Jenkins pipeline, you can use curl to fetch the config dynamically:

pipeline {
    agent any

    stages {
        stage('Fetch Config') {
            steps {
                script {
                    def response = sh(script: "curl -s http://flask-backend-url:5000/get-config", returnStdout: true).trim()
                    def config = readJSON text: response
                    echo "GUI Options: ${config.GUI}"
                    echo "Regress Options: ${config.REGRESS}"
                }
            }
        }
    }
}


4. Allow Frontend Users to Modify the Configuration

In React, create a simple form that fetches the current config from Flask and allows users to modify it.

Use a PUT API in Flask to update the config file:

from flask import request

@app.route('/update-config', methods=['PUT'])
def update_config():
    data = request.json
    with open('config.json', 'w') as file:
        json.dump(data, file, indent=4)
    return jsonify({"message": "Configuration updated successfully"})




Alternative Approach

Instead of storing the configuration in a file, you could use:

1. Database Storage: Store the config in a database like SQLite, PostgreSQL, or MongoDB.


2. Environment Variables: If the config doesn’t change frequently, you can load it into Jenkins from environment variables.



However, your approach with a dynamic file is flexible and keeps things simple. Let me know if you need more details on any part.

