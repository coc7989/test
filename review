""" LSF Flexi Queue Job Migrator

This script intelligently migrates pending jobs from users who have hit their slot limits into a flexi queue, if the cluster has enough spare capacity. It uses scoring-based logic for fairness and prioritization, and records all job moves into an Oracle SQL database to avoid duplicate migrations and for auditing. """

import argparse import subprocess import cx_Oracle import yaml import time from datetime import datetime from collections import defaultdict

-------------------------------- CONFIGURATION --------------------------------

FLEXI_QUEUE = "flexi" FLEXI_QUEUE_CAP = 600 BUFFER_THRESHOLD_RATIO = 0.10  # 10% free capacity

-------------------------------- DB CONNECTION --------------------------------

def get_oracle_connection(): return cx_Oracle.connect(user='oracle_user', password='oracle_password', dsn='oracle_dsn')

----------------------------- LOAD CONFIGURATION ------------------------------

def load_priority_config(): with open('config/user_priority.yaml') as f: user_config = yaml.safe_load(f)['priority_users'] with open('config/project_priority.yaml') as f: project_config = yaml.safe_load(f)['priority_projects'] return set(user_config), set(project_config)

--------------------------- LSF SYSTEM INTERFACES -----------------------------

def run_cmd(cmd): result = subprocess.run(cmd, shell=True, capture_output=True, text=True) if result.returncode != 0: raise RuntimeError(f"Command failed: {cmd}\n{result.stderr}") return result.stdout.strip()

def get_cluster_slots(): output = run_cmd("bhosts") total, running = 0, 0 for line in output.splitlines()[1:]: fields = line.split() total += int(fields[3])  # max slots running += int(fields[4])  # used slots return total, running

def get_user_usage(): output = run_cmd("busers") usage = {} for line in output.splitlines()[1:]: fields = line.split() user = fields[0] run_slots = int(fields[2]) pend_slots = int(fields[3]) quota = int(fields[5]) usage[user] = {'running': run_slots, 'pending': pend_slots, 'quota': quota} return usage

def get_pending_jobs(): output = run_cmd("bjobs -w -p -noheader -J all -q normal -u all") jobs = [] for line in output.splitlines(): fields = line.split() job_id = fields[0] user = fields[1] queue = fields[2] status = fields[3] pend_time = int(time.time() - datetime.strptime(fields[15], '%c').timestamp()) project = fields[13] slots = int(fields[10]) jobs.append({ 'id': job_id, 'user': user, 'queue': queue, 'status': status, 'pend_time': pend_time, 'project': project, 'slots': slots }) return jobs

--------------------------- ORACLE DB HISTORY CHECK ---------------------------

def is_job_already_moved(job_id): conn = get_oracle_connection() cur = conn.cursor() cur.execute("SELECT 1 FROM JOB_MOVE_HISTORY WHERE JOB_ID = :job_id", {'job_id': job_id}) result = cur.fetchone() conn.close() return bool(result)

def record_job_move(job, score, reason, rules_applied, cycle_id): conn = get_oracle_connection() cur = conn.cursor() cur.execute(""" INSERT INTO JOB_MOVE_HISTORY ( JOB_ID, USER_ID, MOVED_FROM_QUEUE, MOVED_TO_QUEUE, MOVE_TIME, MOVE_REASON, PEND_TIME_BEFORE, SCORE, RULES_APPLIED, CYCLE_ID ) VALUES (:1, :2, :3, :4, :5, :6, :7, :8, :9, :10) """, ( job['id'], job['user'], job['queue'], FLEXI_QUEUE, datetime.now(), reason, job['pend_time'], score, ",".join(rules_applied), cycle_id )) conn.commit() conn.close()

------------------------------- SCORING ENGINE -------------------------------

def score_job(job, user_data, priority_users, priority_projects, args): score = 0 rules = []

if not args.disable_project_priority and job['project'] in priority_projects:
    score += 30
    rules.append('project_priority')

if not args.disable_user_priority and job['user'] in priority_users:
    score += 25
    rules.append('user_priority')

if not args.disable_quota_sort:
    quota = user_data[job['user']]['quota']
    if quota <= 50:
        score += 15
        rules.append('low_quota')

if not args.disable_pending_age:
    pend_score = min(job['pend_time'] / 21600, 1.0) * 20  # 6hr max
    score += int(pend_score)
    rules.append('pend_age')

if not args.disable_utilization_check:
    # Placeholder utilization - use real if available
    utilization = 0.3  # Assume 30% used
    score += int((1 - utilization) * 15)
    rules.append('low_utilization')

if not args.disable_long_pending_bonus and job['pend_time'] > 21600:
    score += 5
    rules.append('very_old_job')

return score, rules

------------------------------- JOB MOVER LOGIC -------------------------------

def move_job_to_flexi(job, dry_run=False): if dry_run: print(f"[DRY-RUN] Would move job {job['id']} to {FLEXI_QUEUE}") else: run_cmd(f"bmod -q {FLEXI_QUEUE} {job['id']}") print(f"Moved job {job['id']} to {FLEXI_QUEUE}")

-------------------------------- MAIN FUNCTION --------------------------------

def main(): parser = argparse.ArgumentParser(description="LSF Flexi Queue Job Migrator") parser.add_argument('--dry-run', action='store_true') parser.add_argument('--disable-project-priority', action='store_true') parser.add_argument('--disable-user-priority', action='store_true') parser.add_argument('--disable-quota-sort', action='store_true') parser.add_argument('--disable-pending-age', action='store_true') parser.add_argument('--disable-utilization-check', action='store_true') parser.add_argument('--disable-long-pending-bonus', action='store_true') args = parser.parse_args()

cycle_id = f"cycle_{int(time.time())}"
priority_users, priority_projects = load_priority_config()
user_data = get_user_usage()
total_slots, running_slots = get_cluster_slots()
pending_jobs = get_pending_jobs()
available_slots = total_slots - running_slots

if available_slots < BUFFER_THRESHOLD_RATIO * total_slots:
    print("Cluster too full. Skipping flexi migration.")
    return

scored_jobs = []
for job in pending_jobs:
    if job['user'] not in user_data:
        continue
    user_info = user_data[job['user']]
    if user_info['running'] < user_info['quota']:
        continue
    if is_job_already_moved(job['id']):
        continue

    score, rules = score_job(job, user_data, priority_users, priority_projects, args)
    scored_jobs.append((score, job, rules))

scored_jobs.sort(key=lambda x: x[0], reverse=True)
moved_slots = 0

for score, job, rules in scored_jobs:
    if moved_slots + job['slots'] > FLEXI_QUEUE_CAP:
        break
    move_job_to_flexi(job, dry_run=args.dry_run)
    record_job_move(job, score, reason="score_based", rules_applied=rules, cycle_id=cycle_id)
    moved_slots += job['slots']

if name == 'main': main()

