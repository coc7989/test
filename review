Here is the updated scoring logic section including:

The scoring logic for historical utilization and job efficiency

Modular helper functions: get_user_utilization and get_user_avg_efficiency

Oracle SQL query integration with cx_Oracle



---

üß© Add These at the Top of Your Script (Imports & Time Helpers)

from datetime import datetime, timedelta

def get_epoch_range_for_yesterday():
    now = datetime.now()
    start = (now - timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)
    end = start + timedelta(days=1)
    return int(start.timestamp()), int(end.timestamp())


---

‚öôÔ∏è Helper Function 1: Historical Utilization

def get_user_utilization(user, queue, cluster, quota):
    start_epoch, end_epoch = get_epoch_range_for_yesterday()
    conn = get_oracle_connection()
    cur = conn.cursor()
    cur.execute("""
        SELECT SUM(NUM_SLOTS_REQURESTED * RUN_TIME)
        FROM V_UED_BACCT_INDIA
        WHERE USERID = :user AND QUEUE_NAME = :queue AND CLUSTER_NAME = :cluster
          AND START_TIME BETWEEN :start_time AND :end_time
    """, {
        'user': user,
        'queue': queue,
        'cluster': cluster,
        'start_time': start_epoch,
        'end_time': end_epoch
    })
    result = cur.fetchone()[0]
    conn.close()

    if result is None or quota == 0:
        return 0.0

    quota_seconds = quota * 86400  # 24 hours
    utilization = result / quota_seconds
    return min(utilization, 1.0)


---

‚öôÔ∏è Helper Function 2: Average Job Efficiency

def get_user_avg_efficiency(user, queue, cluster):
    start_epoch, end_epoch = get_epoch_range_for_yesterday()
    conn = get_oracle_connection()
    cur = conn.cursor()
    cur.execute("""
        SELECT AVG(JOB_EFFICIENCY)
        FROM V_UED_BACCT_INDIA
        WHERE USERID = :user AND QUEUE_NAME = :queue AND CLUSTER_NAME = :cluster
          AND START_TIME BETWEEN :start_time AND :end_time
    """, {
        'user': user,
        'queue': queue,
        'cluster': cluster,
        'start_time': start_epoch,
        'end_time': end_epoch
    })
    result = cur.fetchone()[0]
    conn.close()

    return float(result) if result else 0.0


---

üî¢ Updated Score Function

def score_job(job, priority_users, priority_projects, args, cluster_name):
    score = 0
    rules = []

    if not args.disable_project_priority and job['project'] in priority_projects:
        score += 30
        rules.append('project_priority')

    if not args.disable_user_priority and job['user'] in priority_users:
        score += 25
        rules.append('user_priority')

    if not args.disable_quota_sort and job['quota'] <= 50:
        score += 15
        rules.append('default_quota')

    if not args.disable_pending_age:
        pend_score = min(job['pend_time'] / 21600, 1.0) * 20
        score += int(pend_score)
        rules.append('pend_age')

    if not args.disable_utilization_check:
        utilization = job['running'] / job['quota'] if job['quota'] else 0
        score += int((1 - utilization) * 15)
        rules.append('low_realtime_util')

    if not args.disable_utilization_history:
        util_hist = get_user_utilization(job['user'], job['queue'], cluster_name, job['quota'])
        if util_hist <= 0.2:
            score += 15
        elif util_hist <= 0.3:
            score += 10
        elif util_hist <= 0.4:
            score += 5
        rules.append(f'low_hist_util:{round(util_hist, 2)}')

    if not args.disable_efficiency_check:
        eff = get_user_avg_efficiency(job['user'], job['queue'], cluster_name)
        if eff >= 0.90:
            score += 10
        elif eff >= 0.85:
            score += 5
        rules.append(f'efficiency:{round(eff, 2)}')

    if not args.disable_long_pending_bonus and job['pend_time'] > 21600:
        score += 5
        rules.append('very_old_job')

    return score, rules


---

üõ† CLI Flags to Add

Update your argparse with these flags:

parser.add_argument('--disable-utilization-history', action='store_true')
parser.add_argument('--disable-efficiency-check', action='store_true')


---

Let me know if you want this written into the actual script file now. I can also help generate mock Oracle test queries or integrate caching if needed.

