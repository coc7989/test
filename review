from datetime import date
import cx_Oracle  # ensure this is imported somewhere
import traceback

def scheduled_database_removal_query():
    write_to_cron_log("Job started: daily_database_removal_query")
    conn = None
    cursor = None

    try:
        conn = get_oracle_connection()
        cursor = conn.cursor()

        today = date.today().isoformat()
        tables = [
            {"name": dbCfg['QUEUE_ACCESS'], "category": "QUEUE", "extra_filter": "AND QUEUE='priority'"},
            {"name": dbCfg['SLOT_REQUEST'], "category": "SLOT", "extra_filter": ""}
        ]

        query_results = []
        for table in tables:
            rows = fetch_expired_requests(cursor, table["name"], table["extra_filter"], today)
            for row in rows:
                row["CATEGORY_NAME"] = table["category"]
                query_results.append(row)

        for request in query_results:
            process_removal_request(request, conn)

        write_to_cron_log("Job completed: daily_database_removal_query")

    except cx_Oracle.Error as error:
        write_to_api_log(f"[scheduled_database_removal_query] Error: {str(error)}")
        print(f"Database query error: {error}")
        write_to_cron_log(f"Failed with error: {error}")
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

def fetch_expired_requests(cursor, table_name, extra_filter, specific_date):
    sql = f"""
        SELECT REQUEST_ID, USER_AID, CLUSTER_NAME, ACCESS_END_DATE, REQUEST_STATUS, { 'QUEUE' if 'QUEUE_ACCESS' in table_name else 'SLOT_TYPE' } 
        FROM {table_name}
        WHERE REQUEST_STATUS='COMPLETED'
        {extra_filter}
        AND TRUNC(ACCESS_END_DATE) <= TO_DATE(:today, 'YYYY-MM-DD')
    """
    cursor.execute(sql, today=specific_date)
    columns = [col[0] for col in cursor.description]
    return [dict(zip(columns, row)) for row in cursor.fetchall()]

def process_removal_request(request, conn):
    print("Processing request:", request)
    build_result = trigger_jenkins_job_removal(request)

    # Normalize build result
    if build_result == 'SUCCESS':
        final_status = 'ACCESS ENDED'
    elif build_result == 'UNSTABLE':
        final_status = 'QUEUED FOR RETRY'
    else:
        final_status = 'AWAITING ADMIN REVIEW'

    print(f"Build result: {build_result}, Final status: {final_status}")

    category = request.get("CATEGORY_NAME", "").upper()
    table_name = dbCfg['QUEUE_ACCESS'] if category == 'QUEUE' else dbCfg['SLOT_REQUEST']

    update_sql = f"""
        UPDATE {table_name}
        SET UPDATED_DATE = sysdate,
            REQUEST_STATUS = :REQUEST_STATUS
        WHERE REQUEST_ID = :REQUEST_ID
    """
    with conn.cursor() as cursor:
        cursor.execute(update_sql, {
            "REQUEST_STATUS": final_status,
            "REQUEST_ID": request["REQUEST_ID"]
        })
        conn.commit()

    if final_status == 'ACCESS ENDED' and category == 'SLOT':
        upsert_slot_limit(
            conn,
            user_id=request.get("USER_AID"),
            slot_type=request.get("SLOT_TYPE"),
            cluster_name=request.get("CLUSTER_NAME")
        )
