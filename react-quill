gYes, your observation is absolutely correct. Accessing values using hardcoded index positions like record[2] or request[5] is not very readable, error-prone, and makes the code harder to maintain.

✅ Better Way: Use cursor.description + Dictionary Conversion

You can convert each row fetched from the database into a dictionary by using the column names provided by cursor.description. This will allow you to access fields by their names instead of numeric indices, making your code more readable and robust.


---

✅ Revised scheduled_remainder_query() (with dicts)

def scheduled_remainder_query():
    conn = get_oracle_connection()
    cursor = conn.cursor()

    target_date = (date.today() + timedelta(days=3)).isoformat()  # 3 days from today

    query = f"""
        SELECT REQUEST_ID, CLUSTER_NAME, USER_AID, GROUP_AID,
               TO_CHAR(ACCESS_END_DATE, 'YYYY-MM-DD') AS ACCESS_END_DATE,
               PROJECT_NAME, LSB_OPTION, SLOT_POOL, PLM_AID
        FROM {dbCfg['QUEUE_ACCESS']}
        WHERE REQUEST_STATUS='COMPLETED'
          AND QUEUE='priority'
          AND TRUNC(ACCESS_END_DATE) = TO_DATE(:target_date, 'YYYY-MM-DD')
    """

    cursor.execute(query, target_date=target_date)

    columns = [col[0].lower() for col in cursor.description]
    records = [dict(zip(columns, row)) for row in cursor.fetchall()]

    user_records = {}
    for record in records:
        user_aid = record['user_aid']
        if user_aid not in user_records:
            user_records[user_aid] = []
        user_records[user_aid].append(record)

    for user_aid, user_requests in user_records.items():
        send_remainder_email_for_priority_queue(user_aid, user_requests)


---

✅ Revised send_remainder_email_for_priority_queue() (with dicts)

def send_remainder_email_for_priority_queue(user_aid, user_requests):
    branch_name = os.getenv('BRANCH_NAME', 'dev')
    to_email = f"{user_aid}@ti.com"
    cc_email = f"{user_requests[0]['plm_aid']}@ti.com"
    subject = "Reminder: Your Priority Queue Access Requests Expiring in 2 Days"
    recipients = [to_email] + ([cc_email] if cc_email else [])
    portal_link = f"{PORTAL_LINK}/queue"

    tables_html = ""
    for request in user_requests:
        group_sharing = "Yes" if request['lsb_option'] == '1' else "No"
        access_end_date = datetime.strptime(request['access_end_date'], "%Y-%m-%d").strftime("%d %b %Y")

        table_html = f"""
        <table border="1" style="border-collapse:collapse;">
            <tr><th>Field</th><th>Value</th></tr>
            <tr><td>Request ID</td><td>{request['request_id']}</td></tr>
            <tr><td>Cluster Name</td><td>{request['cluster_name']}</td></tr>
            <tr><td>Requested For</td><td>{request['group_aid']}</td></tr>
            <tr><td>Access End Date</td><td>{access_end_date}</td></tr>
            <tr><td>Project Name</td><td>{request['project_name']}</td></tr>
            <tr><td>Group Sharing</td><td>{group_sharing}</td></tr>
            <tr><td>Slots</td><td>{request['slot_pool']}</td></tr>
        </table><br/>
        """
        tables_html += table_html

    email_body = f"""
    <html>
        <body>
            <p><strong>Your priority queue access requests are expiring in 3 days:</strong></p>
            {tables_html}
            <p>If there is a critical business need to extend the access, please extend your access for another 10 days by visiting: <a href="{portal_link}">{portal_link}</a></p>
            <p>Click on access requests -> Locate your request -> Click on extend button</p>
            <p><strong>Access can be extended only 1 or 2 days prior to ending date and not on the ending date.</strong></p>
        </body>
    </html>
    """

    try:
        smtp_server = 'smtp.mail.tf.com'
        smtp_port = 25
        sender_email = "noreply-mylsf@tf.com"

        msg = MIMEMultipart()
        msg['From'] = sender_email
        msg['To'] = to_email
        msg['Cc'] = cc_email
        msg['Subject'] = subject
        msg.attach(MIMEText(email_body, "html"))

        server = smtplib.SMTP(smtp_server, smtp_port)
        server.sendmail(sender_email, recipients, msg.as_string())
        server.quit()

        return jsonify({'message': 'Email sent successfully'}), 200
    except Exception as e:
        write_to_api_log(f"[send_remainder_email_for_priority_queue] Error: {str(e)}")
        return jsonify({'error': str(e)}), 500


---

✅ Benefits of This Change

✅ Readability: Column names make it much easier to understand what's being accessed.

✅ Maintainability: If the column order changes in SQL, your code still works.

✅ Safety: Less risk of using a wrong index.


Let me know if you'd like this wrapped as a utility function (e.g., rows_to_dicts(cursor)), or want to apply it in other places.

